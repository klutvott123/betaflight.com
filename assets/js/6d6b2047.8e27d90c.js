"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2361],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||a;return n?i.createElement(m,s(s({ref:t},d),{},{components:n})):i.createElement(m,s({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[p]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<a;c++)s[c]=n[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},21167:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var i=n(87462),r=(n(67294),n(3905));const a={},s="Bus and External Device Drivers",o={unversionedId:"development/API/BusDrivers",id:"development/API/BusDrivers",title:"Bus and External Device Drivers",description:"Betaflight makes a distinction between external devices and the bus on which they reside. For example each type of gyro will have a device driver which understands the register map of the gyro, and accesses to those registers will be made via a bus driver, either I2C or SPI. A device instance is represented by a extDevicet structure which references a busDevicet structure corresponding to the bus instance via which the device is accesses.",source:"@site/docs/development/API/BusDrivers.mdx",sourceDirName:"development/API",slug:"/development/API/BusDrivers",permalink:"/betaflight.com/docs/development/API/BusDrivers",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"development",previous:{title:"Development",permalink:"/betaflight.com/docs/development/"},next:{title:"Betaflight 4.4 cloud build API",permalink:"/betaflight.com/docs/development/API/Cloud-Build-API"}},l={},c=[{value:"Bus Agnostic Device Access Routines",id:"bus-agnostic-device-access-routines",level:2},{value:"Access routines where the register is accessed directly",id:"access-routines-where-the-register-is-accessed-directly",level:3},{value:"Write routines where the register number is masked with <code>0x7f</code>",id:"write-routines-where-the-register-number-is-masked-with-0x7f",level:3},{value:"Read routines where the register is ORed with <code>0x80</code>",id:"read-routines-where-the-register-is-ored-with-0x80",level:3},{value:"I2C Specific Access",id:"i2c-specific-access",level:2},{value:"SPI Specific Access",id:"spi-specific-access",level:2}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"bus-and-external-device-drivers"},"Bus and External Device Drivers"),(0,r.kt)("p",null,"Betaflight makes a distinction between external devices and the bus on which they reside. For example each type of gyro will have a device driver which understands the register map of the gyro, and accesses to those registers will be made via a bus driver, either I2C or SPI. A device instance is represented by a ",(0,r.kt)("inlineCode",{parentName:"p"},"extDevice_t")," structure which references a ",(0,r.kt)("inlineCode",{parentName:"p"},"busDevice_t")," structure corresponding to the bus instance via which the device is accesses."),(0,r.kt)("h2",{id:"bus-agnostic-device-access-routines"},"Bus Agnostic Device Access Routines"),(0,r.kt)("p",null,"There are a common set of device access functions which are bus agnostic. In each case the device instance handle ",(0,r.kt)("inlineCode",{parentName:"p"},"dev")," is passed to indicate the device to access, and from this the appropriate bus instance is selected."),(0,r.kt)("h3",{id:"access-routines-where-the-register-is-accessed-directly"},"Access routines where the register is accessed directly"),(0,r.kt)("p",null,"These write routines do not mask the value in ",(0,r.kt)("inlineCode",{parentName:"p"},"reg"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool busRawWriteRegister(const extDevice_t *dev, uint8_t reg, uint8_t data);\n")),(0,r.kt)("p",null,"Write the value ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," to the register offset ",(0,r.kt)("inlineCode",{parentName:"p"},"reg"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool busRawWriteRegisterStart(const extDevice_t *dev, uint8_t reg, uint8_t data);\n")),(0,r.kt)("p",null,"Write the value ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," to the register offset ",(0,r.kt)("inlineCode",{parentName:"p"},"reg"),". If the device is on an I2C bus this call is non-blocking and merely starts the access, hence the name suffix, but care should be taken not to call this a second time before the first access has completed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool busRawReadRegisterBuffer(const extDevice_t *dev, uint8_t reg, uint8_t *data, uint8_t length);\n")),(0,r.kt)("p",null,"Read ",(0,r.kt)("inlineCode",{parentName:"p"},"length")," bytes into the buffer at ",(0,r.kt)("inlineCode",{parentName:"p"},"*data")," from the register offset ",(0,r.kt)("inlineCode",{parentName:"p"},"reg"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool busRawReadRegisterBufferStart(const extDevice_t *dev, uint8_t reg, uint8_t *data, uint8_t length);\n")),(0,r.kt)("p",null,"Read ",(0,r.kt)("inlineCode",{parentName:"p"},"length")," bytes into the buffer at ",(0,r.kt)("inlineCode",{parentName:"p"},"*data")," from the register offset ",(0,r.kt)("inlineCode",{parentName:"p"},"reg"),". If the device is on an I2C bus this call is non-blocking and merely starts the access, hence the name suffix."),(0,r.kt)("h3",{id:"write-routines-where-the-register-number-is-masked-with-0x7f"},"Write routines where the register number is masked with ",(0,r.kt)("inlineCode",{parentName:"h3"},"0x7f")),(0,r.kt)("p",null,"It is common to indicate a read from an SPI register by setting but 7 (",(0,r.kt)("inlineCode",{parentName:"p"},"0x80"),") of the register number. There are therefore a number of routines which clear this bit to indicate a write. I2C register addresses are only 7 bits with an explicit read/write bit."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool busWriteRegister(const extDevice_t *dev, uint8_t reg, uint8_t data);\n")),(0,r.kt)("p",null,"Write the value ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," to the register offset ",(0,r.kt)("inlineCode",{parentName:"p"},"reg")," logically anded with ",(0,r.kt)("inlineCode",{parentName:"p"},"0x7f"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool busWriteRegisterStart(const extDevice_t *dev, uint8_t reg, uint8_t data);\n")),(0,r.kt)("p",null,"Write the value ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," to the register offset ",(0,r.kt)("inlineCode",{parentName:"p"},"reg")," logically anded with ",(0,r.kt)("inlineCode",{parentName:"p"},"0x7f"),". If the device is on an I2C bus this call is non-blocking and merely starts the access, hence the name suffix."),(0,r.kt)("h3",{id:"read-routines-where-the-register-is-ored-with-0x80"},"Read routines where the register is ORed with ",(0,r.kt)("inlineCode",{parentName:"h3"},"0x80")),(0,r.kt)("p",null,"It is common to indicate a read from an SPI register by setting but 7 (",(0,r.kt)("inlineCode",{parentName:"p"},"0x80"),") of the register number. There are therefore a number of routines which set this bit to indicate a read. I2C register addresses are only 7 bits with an explicit read/write bit."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"uint8_t busReadRegister(const extDevice_t *dev, uint8_t reg);\n")),(0,r.kt)("p",null,"Read a single byte from the register offset ",(0,r.kt)("inlineCode",{parentName:"p"},"reg")," logically anded with ",(0,r.kt)("inlineCode",{parentName:"p"},"0x80"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool busReadRegisterBuffer(const extDevice_t *dev, uint8_t reg, uint8_t *data, uint8_t length);\n")),(0,r.kt)("p",null,"Read ",(0,r.kt)("inlineCode",{parentName:"p"},"length")," bytes into the buffer at ",(0,r.kt)("inlineCode",{parentName:"p"},"*data")," from the register offset ",(0,r.kt)("inlineCode",{parentName:"p"},"reg")," logically anded with ",(0,r.kt)("inlineCode",{parentName:"p"},"0x80"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool busReadRegisterBufferStart(const extDevice_t *dev, uint8_t reg, uint8_t *data, uint8_t length);\n")),(0,r.kt)("p",null,"Read ",(0,r.kt)("inlineCode",{parentName:"p"},"length")," bytes into the buffer at ",(0,r.kt)("inlineCode",{parentName:"p"},"*data")," from the register offset ",(0,r.kt)("inlineCode",{parentName:"p"},"reg")," logically anded with ",(0,r.kt)("inlineCode",{parentName:"p"},"0x80"),". If the device is on an I2C bus this call is non-blocking and merely starts the access, hence the name suffix."),(0,r.kt)("h2",{id:"i2c-specific-access"},"I2C Specific Access"),(0,r.kt)("p",null,"I2C bus accesses are slow and therefore, except during startup device initialisation, the use of blocking accesses should be avoided. Therefore the ",(0,r.kt)("inlineCode",{parentName:"p"},"bus...Start()")," routines should be used which use interrupts to handle the transfer in the background. The barometer driver is a good example of how I2C devices accesses should be performed, with a state machine used so that accesses are started in one state, and the processing of the result of a read, or launching the next write waits until the next state."),(0,r.kt)("p",null,"It is necessary to register a device as being on an I2C bus in order that it can be accessed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool i2cBusSetInstance(const extDevice_t *dev, uint32_t device);\n")),(0,r.kt)("p",null,"This registers the external device ",(0,r.kt)("inlineCode",{parentName:"p"},"dev")," with an I2C bus device instance ",(0,r.kt)("inlineCode",{parentName:"p"},"device"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"void i2cBusDeviceRegister(const extDevice_t *dev);\n")),(0,r.kt)("p",null,"A call to ",(0,r.kt)("inlineCode",{parentName:"p"},"i2cBusDeviceRegister")," simply increments a count of the number of I2C devices in use."),(0,r.kt)("h2",{id:"spi-specific-access"},"SPI Specific Access"),(0,r.kt)("p",null,"SPI attached devices are accessed at higher speed and therefore may be accessed using blocking read/writes, however longer transfers or accesses requiring multiple transfers are better performed using DMA transfers under interrupt control."),(0,r.kt)("p",null,"There are a number of SPI specific bus access routines to facilitate such optimisation."),(0,r.kt)("p",null,"As with I2C it is possible to have multiple devices share a common SPI bus."),(0,r.kt)("p",null,"It is necessary to register a device as being on an SPI bus in order that it can be accessed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool spiSetBusInstance(extDevice_t *dev, uint32_t device);\n")),(0,r.kt)("p",null,"This registers the external device ",(0,r.kt)("inlineCode",{parentName:"p"},"dev")," with an SPI bus device instance ",(0,r.kt)("inlineCode",{parentName:"p"},"device"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"void spiSetClkDivisor(const extDevice_t *dev, uint16_t divider);\n")),(0,r.kt)("p",null,"Each device on an SPI bus can use a different SPI bus clock speed and this sets the clock divisor to be used for accesses by the given device."),(0,r.kt)("p",null,"Two utility routines are provided to determine the ",(0,r.kt)("inlineCode",{parentName:"p"},"divider")," value to use in order to achieve a max SPI clock speed, and to return the actual clock speed corresponding to that divisor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"// Determine the divisor to use for a given bus frequency\nuint16_t spiCalculateDivider(uint32_t freq);\n// Return the SPI clock based on the given divisor\nuint32_t spiCalculateClock(uint16_t spiClkDivisor);\n")),(0,r.kt)("p",null,"Access to SPI devices requires that the clock phase/polarity be set appropriately. See ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Serial_Peripheral_Interface"},"https://en.wikipedia.org/wiki/Serial_Peripheral_Interface"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"void spiSetClkPhasePolarity(const extDevice_t *dev, bool leadingEdge);\n")),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"leadingEdge")," is set to true, the default, then data will be clocked on the first rising edge of the clock, or if false, on the second falling edge."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"void spiDmaEnable(const extDevice_t *dev, bool enable);\n")),(0,r.kt)("p",null,"Certain devices, such as the CC2500 cannot handle the timing of sequential accesses which are being DMAed, so this enables DMA to be enabled (default) or disabled on a per device basis."),(0,r.kt)("p",null,"In order to support efficient use of SPI it is possible to perform not only single accesses as described above, but also to define a sequence of transfers using an array of ",(0,r.kt)("inlineCode",{parentName:"p"},"busSegment_t")," elements which then comprise a complete transaction. These may be complex, support polling bus status for example before performing a write."),(0,r.kt)("p",null,"Each ",(0,r.kt)("inlineCode",{parentName:"p"},"busSegment_t")," element passes a union of either a pair of buffer pointers for write/read respectively, a null link structure used to terminate the list. Following is the number of bytes in the transfer, a boolean, ",(0,r.kt)("inlineCode",{parentName:"p"},"negateCS"),", indicating if the SPI CS line should be negated at the end of the segment, and an optional callback routine."),(0,r.kt)("p",null,"A good example of this is in ",(0,r.kt)("inlineCode",{parentName:"p"},"m25p16_readBytes()")," where a segment list is defined thus:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"    busSegment_t segments[] = {\n            {.u.buffers = {readStatus, readyStatus}, sizeof(readStatus), true, m25p16_callbackReady},\n            {.u.buffers = {readBytes, NULL}, fdevice->isLargeFlash ? 5 : 4, false, NULL},\n            {.u.buffers = {NULL, buffer}, length, true, NULL},\n            {.u.link = {NULL, NULL}, 0, true, NULL},\n    };\n")),(0,r.kt)("p",null,"In the above example the busy status of the FLASH memory is polled in the first element and then ",(0,r.kt)("inlineCode",{parentName:"p"},"m25p16_callbackReady()")," is called which checks the read status. If the device is busy the value ",(0,r.kt)("inlineCode",{parentName:"p"},"BUS_BUSY")," is returned and the element will be repeated under interrupt/DMA control. If the device is ready to accept a new command then ",(0,r.kt)("inlineCode",{parentName:"p"},"BUS_READY")," is returned and the next element is processed. ",(0,r.kt)("inlineCode",{parentName:"p"},"BUS_ABORT")," may also be returned in abort the whole transaction, although this is not currently used."),(0,r.kt)("p",null,"It can be faster to perform short transfers using polled access rather than setting up DMAs and the rules are as follows to determine if DMA should be use."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"DMA is enabled on the bus and device"),(0,r.kt)("li",{parentName:"ol"},"All transmit/receive buffers are in memory supporting DMAs"),(0,r.kt)("li",{parentName:"ol"},"One of the following:",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"There are are at least ",(0,r.kt)("inlineCode",{parentName:"li"},"SPI_DMA_THRESHOLD")," bytes to transfer"),(0,r.kt)("li",{parentName:"ol"},"There is more than a single element in the segment list"),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"negateCS")," boolean is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"false")," in the terminating entry of the list.")))),(0,r.kt)("p",null,"The ELRS driver in ",(0,r.kt)("inlineCode",{parentName:"p"},"rx_sx1280.c")," is an example of 3.3 where the terminating link has ",(0,r.kt)("inlineCode",{parentName:"p"},"negateCS")," set to ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". This then ensures that all accesses run in the background without blocking."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"void spiSequence(const extDevice_t *dev, busSegment_t *segments);\n")),(0,r.kt)("p",null,"This routine queues the given segment list for processing. If the device's bus is already busy then this segment list will be linked to the preceeding one in the queue so that the accesses will automatically proceed one after the other as quickly as possible."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"void spiWait(const extDevice_t *dev);\n")),(0,r.kt)("p",null,"Block, waiting for completion of the indicated device's bus activity."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bool spiIsBusy(const extDevice_t *dev);\n")),(0,r.kt)("p",null,"Return true if the device's bus is busy."))}p.isMDXComponent=!0}}]);